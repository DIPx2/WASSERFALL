============================================================
 SSH COMMAND EXECUTOR — СПРАВКА ПО КОМАНДНОЙ СТРОКЕ
============================================================

Назначение:
  Выполнение OS-команд на удалённых Linux-хостах по SSH.
  Команды берутся из таблицы "commands" (wasserfall_config.db)
  или передаются напрямую.

  Все результаты логируются в:
    - execution_tasks
    - execution_results
  через модуль common/logger.py.

============================================================
 СИНТАКСИС
============================================================

  python command_executor_ssh/main.py --cmd <COMMAND> [OPTIONS]

============================================================
 ОБЯЗАТЕЛЬНЫЕ ПАРАМЕТРЫ
============================================================

  --cmd <NAME>        Имя команды из таблицы commands
                      или прямая команда (например: "uptime").

============================================================
 ОСНОВНЫЕ ОПЦИИ
============================================================

  --host <HOST>       Выполнить команду только на одном хосте.
                      Если не указано — выполняется на всех
                      активных хостах (hosts.toggle = 1).

  --workers <N>       Количество параллельных потоков.
                      По умолчанию: 5.

  --var key=value     Передача переменных в шаблон команды.
                      Можно указывать несколько раз.

  --sudo              Выполнить команду через sudo.
  --sudo-user <USER>  Пользователь sudo (по умолчанию root).

  --timeout <SEC>     Таймаут выполнения SSH-команды.
                      По умолчанию: 60 секунд.

  --allow-new-hosts   Разрешить автоматическое добавление
                      новых хостов в known_hosts.

  --dry-run           Показать команду, но не выполнять её.

  --verbose           Подробный вывод:
                        - stdout
                        - stderr
                        - exit-коды

============================================================
 ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
============================================================

  1) Выполнить команду WHOAMI на всех активных хостах:

      python command_executor_ssh/main.py --cmd WHOAMI

  2) Выполнить команду только на одном хосте:

      python command_executor_ssh/main.py --cmd WHOAMI \
             --host dev-msg-pg-01.maxbit.private

  3) Подробный вывод (stdout + stderr):

      python command_executor_ssh/main.py --cmd CHECK_DISK --verbose

  4) Передача переменных в шаблон:

      python command_executor_ssh/main.py --cmd CHECK_LOGS \
             --var lines=200 --verbose

  5) Выполнение через sudo:

      python command_executor_ssh/main.py --cmd CHECK_SERVICES --sudo

  6) Dry-run (показать команду без выполнения):

      python command_executor_ssh/main.py --cmd CHECK_MEMORY --dry-run

  7) Автоматическое добавление хостов в known_hosts:

      python command_executor_ssh/main.py --cmd WHOAMI --allow-new-hosts

============================================================
 КОДЫ ВЫПОЛНЕНИЯ
============================================================

  SSH-коды:
    ssh_0     Подключение успешно
    ssh_99    Хост недоступен / ошибка SSH / нет в known_hosts

  Коды команд:
    cmd_0     Команда выполнена успешно
    cmd_10    Команда не найдена
    cmd_12    Нет прав (sudo / permission denied)
    cmd_16    Таймаут выполнения
    cmd_18    Ошибка выполнения команды
    cmd_99    Неизвестная ошибка

  Человекочитаемые статусы:
    OK            cmd_0 / ssh_0
    FAILED        cmd_10 / cmd_12 / cmd_16 / cmd_18
    UNREACHABLE   ssh_99

============================================================
 ЛОГИРОВАНИЕ
============================================================

  Все операции записываются в wasserfall_logger.db:

  Таблица execution_tasks:
    task_id       INTEGER PRIMARY KEY
    target_host   TEXT
    query_text    TEXT
    started_at    DATETIME
    database_name TEXT (для SSH = NULL)

  Таблица execution_results:
    result_id     INTEGER PRIMARY KEY
    task_id       INTEGER (FK)
    pg_code       TEXT (cmd_XX / ssh_XX)
    exit_code     INTEGER
    stdout_json   TEXT (JSON: stdout, stderr, exit_code)
    stderr_text   TEXT
    finished_at   DATETIME

  Пример stdout_json:
    {
      "stdout": "postgres",
      "stderr": "",
      "exit_code": 0
    }

============================================================
 ASCII-ДИАГРАММА АРХИТЕКТУРЫ
============================================================

                       +---------------------------+
                       |   command_executor_ssh    |
                       |---------------------------|
                       | main.py                   |
                       | modules/ssh_runner.py     |
                       +-------------+-------------+
                                     |
                                     | вызывает
                                     v
                       +---------------------------+
                       |          common           |
                       |---------------------------|
                       | getter.py                |
                       | logger.py                |
                       | template_engine.py       |
                       +-------------+-------------+
                                     |
                                     | читает конфиг / пишет логи
                                     v
         +---------------------------+---------------------------+
         |                        databases                     |
         |------------------------------------------------------|
         | wasserfall_config.db   |   wasserfall_logger.db      |
         |-------------------------+-----------------------------|
         | hosts                   | execution_tasks             |
         | commands                | execution_results           |
         | ssh_variables           |                             |
         +-------------------------+-----------------------------+

============================================================
 ТИПИЧНЫЕ ОШИБКИ И РЕШЕНИЯ
============================================================

  1) ssh_99: Host not found in known_hosts
     Причина:
       - хост отсутствует в known_hosts
       - флаг --allow-new-hosts не указан
     Решение:
       - добавить вручную: ssh root@host
       - или запускать с --allow-new-hosts

  2) ssh_99: getaddrinfo failed
     Причина:
       - DNS не может разрешить имя хоста
     Решение:
       - проверить nslookup host
       - проверить VPN
       - прописать IP в hosts-файл

  3) cmd_10: Command not found
     Причина:
       - команда отсутствует в системе
     Решение:
       - проверить шаблон в таблице commands

  4) cmd_12: Permission denied
     Причина:
       - нет прав sudo
     Решение:
       - добавить --sudo
       - указать sudo-user

  5) cmd_16: Timeout
     Причина:
       - команда выполняется слишком долго
     Решение:
       - увеличить --timeout

============================================================
 КАК ДОБАВИТЬ НОВУЮ КОМАНДУ В ТАБЛИЦУ commands
============================================================

  Таблица commands имеет поля:
    id          INTEGER PRIMARY KEY
    name        TEXT UNIQUE
    template    TEXT
    description TEXT

  Пример добавления OS-команды:

    INSERT INTO commands (name, template, description)
    VALUES ('CHECK_UPTIME', 'uptime', 'Время работы системы');

  Пример добавления команды с шаблоном:

    INSERT INTO commands (name, template, description)
    VALUES (
      'CHECK_LOGS',
      'tail -n {{lines}} /var/log/syslog',
      'Просмотр логов'
    );

  После добавления команда доступна через:

    python command_executor_ssh/main.py --cmd CHECK_LOGS --var lines=200

============================================================
 КАК РАБОТАЕТ ШАБЛОНИЗАЦИЯ JINJA2
============================================================

Шаблоны команд хранятся в таблице "commands" (wasserfall_config.db)
в поле "template". Формат шаблонов — Jinja2.

Это позволяет:
  - подставлять переменные (--var key=value)
  - выполнять условные конструкции
  - использовать циклы
  - формировать динамические команды

------------------------------------------------------------
 Пример шаблона в таблице commands
------------------------------------------------------------

  template = 'tail -n {{ lines }} /var/log/syslog'

Запуск:

  python main.py --cmd CHECK_LOGS --var lines=200

Результат рендеринга:

  tail -n 200 /var/log/syslog

------------------------------------------------------------
 Пример шаблона с условием
------------------------------------------------------------

  template = '
  df -h {{ path if path is defined else "/" }}
  '

Запуск:

  python main.py --cmd CHECK_DISK --var path=/var

Результат:

  df -h /var

------------------------------------------------------------
 Пример шаблона с условием и значением по умолчанию
------------------------------------------------------------

  template = '
  {% if limit %}
      tail -n {{ limit }} /var/log/syslog
  {% else %}
      tail -n 50 /var/log/syslog
  {% endif %}
  '

Запуск:

  python main.py --cmd CHECK_LOGS

Результат:

  tail -n 50 /var/log/syslog

------------------------------------------------------------
 Где происходит рендеринг
------------------------------------------------------------

Рендеринг выполняется в:

  common/template_engine.py

Функция:

  render_sql(template_str, context)

где:
  template_str — текст шаблона
  context — словарь переменных, собранных из --var

------------------------------------------------------------
 Ограничения и рекомендации
------------------------------------------------------------

  - Все переменные должны быть строками.
  - Если переменная не передана — используйте условия {% if var %}.
  - Шаблоны должны быть безопасными: не допускайте инъекций.
  - Jinja2 позволяет использовать фильтры, но лучше ограничиться
    простыми конструкциями для читаемости.

============================================================
 КАК РАБОТАЕТ ПАРАЛЛЕЛИЗМ (ThreadPoolExecutor)
============================================================

SSH-команды выполняются параллельно с помощью:

  concurrent.futures.ThreadPoolExecutor

Это позволяет:
  - запускать команды на нескольких хостах одновременно
  - ускорять выполнение массовых операций
  - не блокировать основной поток

------------------------------------------------------------
 Основная схема работы
------------------------------------------------------------

  with ThreadPoolExecutor(max_workers=N) as executor:
      futures = {
          executor.submit(process_host, host, ...): host
          for host in hosts
      }

      for future in as_completed(futures):
          host = futures[future]
          result = future.result()
          ...

------------------------------------------------------------
 Что делает executor.submit()
------------------------------------------------------------

  - создаёт задачу (future)
  - запускает функцию process_host() в отдельном потоке
  - возвращает объект Future

------------------------------------------------------------
 Что делает as_completed()
------------------------------------------------------------

  - ждёт завершения задач
  - возвращает futures в порядке завершения
  - позволяет обрабатывать результаты по мере готовности

------------------------------------------------------------
 Почему используется ThreadPoolExecutor, а не ProcessPoolExecutor?
------------------------------------------------------------

  - SSH — это I/O-bound задача (ожидание сети)
  - GIL не мешает I/O-bound задачам
  - ThreadPoolExecutor быстрее создаёт потоки
  - ProcessPoolExecutor создаёт отдельные процессы → избыточно

------------------------------------------------------------
 Как управлять количеством потоков
------------------------------------------------------------

Параметр:

  --workers N

По умолчанию:

  5 потоков

Рекомендации:
  - 5–10 потоков — оптимально для SSH
  - слишком много потоков → нагрузка на сеть и CPU
  - слишком мало потоков → медленное выполнение

------------------------------------------------------------
 Что происходит внутри process_host()
------------------------------------------------------------

  1. Получение конфигурации хоста
  2. Рендеринг шаблона команды
  3. Установка SSH-соединения
  4. Выполнение команды
  5. Логирование результата
  6. Закрытие SSH-соединения

Каждый поток выполняет эти шаги независимо.

------------------------------------------------------------
 Гарантии безопасности
------------------------------------------------------------

  - Потоки не разделяют SSH-соединения.
  - Каждый поток создаёт своё соединение.
  - Логирование потокобезопасно, т.к. SQLite допускает
    параллельные INSERT (каждый INSERT — транзакция).


============================================================
 КАК РАБОТАЕТ ЛОГИРОВАНИЕ В SQLITE
============================================================

Логирование — единый механизм для SSH и PostgreSQL команд.
Вся информация записывается в wasserfall_logger.db через
функцию common/logger.py::log_execution().

------------------------------------------------------------
 Общая схема логирования
------------------------------------------------------------

  1. Создаётся запись в execution_tasks:
       - target_host
       - query_text
       - started_at
       - database_name (NULL для SSH)

  2. После выполнения команды создаётся запись в execution_results:
       - task_id (FK → execution_tasks)
       - pg_code (cmd_XX / ssh_XX / pg_XX)
       - exit_code
       - stdout_json (stdout, stderr, exit_code)
       - stderr_text
       - finished_at

------------------------------------------------------------
 Пример записи в execution_tasks
------------------------------------------------------------

  task_id     = 42
  target_host = 'dev-msg-pg-01.maxbit.private'
  query_text  = 'ss -ltpn'
  started_at  = '2026-02-22 09:15:33'
  database_name = NULL

------------------------------------------------------------
 Пример записи в execution_results
------------------------------------------------------------

  result_id   = 42
  task_id     = 42
  pg_code     = 'cmd_0'
  exit_code   = 0
  stdout_json = '{"stdout": "...", "stderr": "", "exit_code": 0}'
  stderr_text = ''
  finished_at = '2026-02-22 09:15:33'

------------------------------------------------------------
 Пример SQL-запросов для анализа логов
------------------------------------------------------------

  -- Последние 20 задач
  SELECT * FROM execution_tasks ORDER BY task_id DESC LIMIT 20;

  -- Результаты конкретной задачи
  SELECT * FROM execution_results WHERE task_id = 42;

  -- Все ошибки SSH
  SELECT * FROM execution_results WHERE pg_code LIKE 'ssh_%';

  -- Все ошибки команд
  SELECT * FROM execution_results WHERE pg_code LIKE 'cmd_%' AND exit_code != 0;

------------------------------------------------------------
 Особенности реализации
------------------------------------------------------------

  - SQLite допускает параллельные INSERT → логирование потокобезопасно.
  - stdout_json хранит полный результат выполнения.
  - stderr_text дублирует stderr для удобства поиска.
  - database_name всегда NULL для SSH-команд.
  - pg_code — универсальный код результата.

============================================================
 КАК РАБОТАЕТ SSH-ПОДКЛЮЧЕНИЕ (АЛГОРИТМ)
============================================================

SSH-подключение выполняется через common/getter.py::get_ssh_connection().
Используется библиотека paramiko.

------------------------------------------------------------
 Алгоритм подключения
------------------------------------------------------------

  1. Загрузка SSH-переменных хоста:
       - SSH_USER
       - SSH_KEY_PATH
       - SSH_TIMEOUT
       - SSH_ALLOW_NEW_HOSTS

  2. Подготовка SSH-клиента:
       Если allow_new_hosts = True:
           client.set_missing_host_key_policy(AutoAddPolicy)
       Иначе:
           client.set_missing_host_key_policy(RejectPolicy)

  3. Попытка подключения:
       client.connect(
           hostname,
           username,
           key_filename,
           timeout
       )

  4. Возврат результата:
       Успех → ssh_0
       Ошибка → ssh_99 + текст ошибки

------------------------------------------------------------
 Типичные ошибки SSH
------------------------------------------------------------

  ssh_99: getaddrinfo failed
      DNS не может разрешить имя хоста.

  ssh_99: timed out
      Хост недоступен по сети / порт 22 закрыт.

  ssh_99: Server not found in known_hosts
      Хост отсутствует в known_hosts, а allow_new_hosts=False.

  ssh_99: Permission denied (publickey)
      Неверный ключ или неправильный SSH_USER.

------------------------------------------------------------
 Пример успешного подключения
------------------------------------------------------------

  client, code = get_ssh_connection(
      username='root',
      hostname='dev-msg-pg-01.maxbit.private',
      key_path='/key/id_ed25519',
      timeout=10,
      allow_new_hosts=True
  )

  code == 'ssh_0'  → подключение успешно

------------------------------------------------------------
 Пример неуспешного подключения
------------------------------------------------------------

  client, code = get_ssh_connection(...)
  code == 'ssh_99: Server not found in known_hosts'

  Решение:
    - добавить хост вручную через ssh
    - или использовать --allow-new-hosts

------------------------------------------------------------
 Где используется SSH-подключение
------------------------------------------------------------

  - Внутри process_host() (main.py)
  - Каждый поток создаёт своё SSH-соединение
  - Соединение закрывается в блоке finally

------------------------------------------------------------
 Гарантии безопасности
------------------------------------------------------------

  - Ключи не кэшируются и не передаются между потоками.
  - Каждый поток создаёт собственный SSHClient().
  - known_hosts используется строго по политике allow_new_hosts.
  - Ошибки классифицируются в ssh_XX-коды.

============================================================
 КОНЕЦ ДОПОЛНИТЕЛЬНЫХ РАЗДЕЛОВ
============================================================


============================================================
 КОНЕЦ СПРАВКИ
============================================================
